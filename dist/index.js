import {PluginRegistry,ResourceMerger}from'@cruxjs/base';export*from'@cruxjs/base';import {Logger}from'@minejs/logger';import {server}from'@minejs/server';import {DB}from'@minejs/db';import*as k from'sass';import*as v from'path';async function j(s,r){if(!s.client)return null;r.info("Building client...");try{let e=await Bun.build({entrypoints:[s.client.entry],outdir:s.client.output,target:s.client.target||"browser",minify:s.client.minify??!s.debug,sourcemap:s.client.sourcemap??s.debug?"inline":"none",external:s.client.external||[]});if(!e.success)throw new Error("Build failed");let t=e.outputs.map(i=>i.path);return await H(t,s,r),r.debug(`Client built \u2192 ${t.join(", ")}`),{success:!0,outputs:t}}catch(e){throw r.error("Failed to build client",e.message),e}}async function H(s,r,e){if(!r.client?.entry)return;let t=s.find(i=>i.endsWith(".js"));if(t){e.info("Optimizing bundle (removing unused icons)...");try{let n=await Bun.file(t).text(),u=[],d=new Set,o=0;for(;o<n.length;){let f=n[o];if(f==='"'||f==="'"){let y=f;for(o++;o<n.length&&!(n[o]===y&&n[o-1]!=="\\");)o++;}else if(f==="{"){let y=n.substring(o+1,o+100);if(/^\s*(?:["'][\w-]+["']|\w+)\s*:\s*\{\s*(?:category|viewBox|svg)\b/.test(y)){let a=o,l=1,p=o+1,h=!1,C="";for(;p<n.length;){let g=n[p];if(h)g===C&&n[p-1]!=="\\"&&(h=!1);else if(g==='"'||g==="'")h=!0,C=g;else if(g==="{")l++;else if(g==="}"&&(l--,l===0))break;p++;}let E=p+1,$=n.substring(a,E),R=[],x=/(?:["']([\w-]+)["']|(\w+))\s*:\s*\{/g,b;for(;(b=x.exec($))!==null;){let g=b[1]||b[2];R.push(g),d.add(g);}u.push({start:a,end:E,keys:R}),o=E-1;}}o++;}if(e.debug(`Found ${u.length} icon maps with ${d.size} total icons.`),d.size===0)return;let m=v.dirname(r.client.entry),c=new Bun.Glob("**/*.{ts,tsx,js,jsx}"),A=new Set;for await(let f of c.scan({cwd:m})){let y=v.join(m,f),a=await Bun.file(y).text();for(let l of d)if(!A.has(l)){let p=l.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");new RegExp(`\\b${p}\\b`).test(a)&&A.add(l);}}e.debug(`Used icons: ${A.size}`);let w="",S=0;for(let f of u){w+=n.substring(S,f.start);let y=n.substring(f.start,f.end),a;try{a=new Function("return "+y)();}catch{e.warn("Failed to parse map, keeping as is"),w+=y,S=f.end;continue}let l=0;for(let p of f.keys)A.has(p)||(delete a[p],l++);l>0?w+=JSON.stringify(a):w+=y,S=f.end;}w+=n.substring(S),await Bun.write(t,w),e.info("Bundle optimized");}catch(i){e.warn("Failed to optimize bundle",i.message);}}}async function I(s,r){if(!s.style)return r.info("No style config provided, skipping style build"),null;r.info(`Building styles from: ${s.style.entry}...`);try{let e=s.style.output,t=e.lastIndexOf("/"),i=e.substring(0,t),n=e.substring(t+1),{mkdir:u}=await import('fs/promises');await u(i,{recursive:!0});let d=k.compile(s.style.entry,{style:s.style.minify?"compressed":"expanded",sourceMap:!!s.style.sourcemap});return await Bun.write(e,d.css),r.info(`Compiled SCSS to CSS \u2192 ${n}`),r.debug(`Styles built \u2192 ${e}`),{success:!0,output:e}}catch(e){return r.error("Failed to build styles",e.message),{success:false,output:s.style?.output||"unknown"}}}async function z(s,r,e){let t=new Map;if(!s.database&&r.length===0)return e.info("No database config, skipping setup"),t;let i=s.database?Array.isArray(s.database)?s.database:[s.database]:[];e.info("Setting up databases...");for(let n of i){let u=n.name||"default",d=new DB(n.connection);if(n.schema)try{let o=await import(n.schema),m=o.default||o.schema;if(Array.isArray(m))for(let c of m)d.defineSchema(c);}catch(o){throw e.error(`Failed to load schema: ${n.schema}`,o.message),o}for(let o of r)d.defineSchema(o);t.set(u,d),e.debug(`Database '${u}' ready`);}if(t.size===0&&r.length>0){let n=new DB(":memory:");for(let u of r)n.defineSchema(u);t.set("default",n),e.debug("Database 'default' ready (in-memory for plugins)");}return t}async function P(s,r){if(!s.api)return [];r.info(`Loading routes from ${s.api.directory}...`);let e=[];try{let t=await T(s.api.directory);for(let i of t)try{let n=await import(i),u=n.default||n.routes;Array.isArray(u)&&e.push(...u);}catch(n){r.error(`Failed to load routes from ${i}`,n.message);}return r.debug(`Routes loaded \u2192 ${e.length} routes`),e}catch(t){return r.error("Failed to scan route directory",t.message),[]}}async function T(s){let r=[];try{let e=await Array.fromAsync(new Bun.Glob("**/*.{ts,js}").scan(s));for(let t of e)r.push(`${s}/${t}`);}catch{}return r}function Q(s,r){let e=r?.onConfig?r.onConfig(s):s,t=new Logger(e.debug?"debug":"info",true,"CruxJS"),i=new PluginRegistry(t),n=new ResourceMerger(t),u=new Map,d=new Map,o=null,m=null,c={config:e,databases:u,plugins:[]},A={config:e,server:null,databases:u,plugins:[],middlewares:d,start:async()=>{},stop:async()=>{},restart:async()=>{},getContext:()=>c,getMiddleware:a=>d.get(a)};async function w(){if(!e.plugins||e.plugins.length===0){t.info("No plugins to register");return}t.debug("REGISTER");for(let l of e.plugins)await i.register(l,A);c.plugins=i.getAll(),i.collectMiddlewares().forEach((l,p)=>d.set(p,l));}async function S(){t.debug("AWAKE");try{m=await j(e,t),c.clientBuild=m;let a=await I(e,t);c.styleBuild=a;let l=i.collectSchemas(),p=await z(e,l,t);u.clear(),p.forEach((h,C)=>u.set(C,h)),await i.callHook("onAwake",c),await r?.onAwake?.(c);}catch(a){throw await r?.onError?.(c,"AWAKE",a),a}}async function f(){t.debug("START");try{let a=await P(e,t),l=i.collectRoutes(),h=[...e.routes||[],...a],C=n.mergeRoutes(h,l),E=e.static?Array.isArray(e.static)?e.static:[e.static]:[],$=i.collectStatic(),R=n.mergeStatic(E,$);t.info("Creating server...");let x;for(let b of c.plugins){let g=b;if(g.__spaErrorHandler){x=g.__spaErrorHandler,console.log(`[CruxJS] \u2713 Error handler collected from: ${b.name}`);break}}o=await server({port:e.server?.port||3e3,hostname:e.server?.host||"localhost",logging:e.server?.logging,routes:C,static:R.length>0?R:void 0,security:e.security,middlewares:e.middlewares,i18n:e.i18n?{defaultLanguage:e.i18n.defaultLanguage,supportedLanguages:e.i18n.supportedLanguages,basePath:e.i18n.basePath,fileExtension:e.i18n.fileExtension||"json"}:void 0,onError:x}),u.forEach((b,g)=>{o.db.set(g,b);}),c.server=o,A.server=o,t.debug(`Server created \u2192 ${e.server?.host||"localhost"}:${e.server?.port||3e3}`),await i.callHook("onStart",c),await r?.onStart?.(c);}catch(a){throw await r?.onError?.(c,"START",a),a}}async function y(){t.debug("READY");try{await o.start(),t.debug(`Server running on http://${e.server?.host||"localhost"}:${e.server?.port||3e3}`),await i.callHook("onReady",c),await r?.onReady?.(c);}catch(a){throw await r?.onError?.(c,"READY",a),a}}return {config:e,server:o,databases:u,plugins:c.plugins,middlewares:d,async start(){await w(),await S(),await f(),await y();},async stop(){t.info("Stopping server...");try{o&&await o.stop(),u.forEach((a,l)=>{a.close(),t.info(`Database '${l}' closed`);}),await i.callHook("onShutdown",c),await r?.onFinish?.(c),t.debug("Server stopped");}catch(a){throw t.error("Failed to stop server",a.message),a}},async restart(){await this.stop(),await this.start();},getContext(){return c},getMiddleware(a){return d.get(a)}}}
export{Q as createApp,H as optimizeBundle};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map